{"ast":null,"code":"/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(rawString);\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n  let startLine = 0;\n  while (startLine < lines.length && isBlank(lines[startLine])) {\n    ++startLine;\n  }\n  let endLine = lines.length;\n  while (endLine > startLine && isBlank(lines[endLine - 1])) {\n    --endLine;\n  } // Return a string of the lines joined with U+000A.\n\n  return lines.slice(startLine, endLine).join('\\n');\n}\nfunction isBlank(str) {\n  for (const char of str) {\n    if (char !== ' ' && char !== '\\t') {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * @internal\n */\n\nexport function getBlockStringIndentation(value) {\n  var _commonIndent;\n  let isFirstLine = true;\n  let isEmptyLine = true;\n  let indent = 0;\n  let commonIndent = null;\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.charCodeAt(i)) {\n      case 13:\n        //  \\r\n        if (value.charCodeAt(i + 1) === 10) {\n          ++i; // skip \\r\\n as one symbol\n        }\n\n      // falls through\n\n      case 10:\n        //  \\n\n        isFirstLine = false;\n        isEmptyLine = true;\n        indent = 0;\n        break;\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        ++indent;\n        break;\n      default:\n        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {\n          commonIndent = indent;\n        }\n        isEmptyLine = false;\n    }\n  }\n  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, preferMultipleLines = false) {\n  const isSingleLine = !value.includes('\\n');\n  const hasLeadingSpace = value.startsWith(' ') || value.startsWith('\\t');\n  const hasTrailingQuote = value.endsWith('\"');\n  const hasTrailingSlash = value.endsWith('\\\\');\n  const printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;\n  let result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n';\n  }\n  result += value;\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}","map":{"version":3,"names":["dedentBlockStringValue","rawString","lines","split","commonIndent","getBlockStringIndentation","i","length","slice","startLine","isBlank","endLine","join","str","char","value","_commonIndent","isFirstLine","isEmptyLine","indent","charCodeAt","printBlockString","preferMultipleLines","isSingleLine","includes","hasLeadingSpace","startsWith","hasTrailingQuote","endsWith","hasTrailingSlash","printAsMultipleLines","result","replace"],"sources":["C:/Users/natus/Desktop/Reliquest Assessment/ui-assessment-pokedex-snr/node_modules/graphql/language/blockString.mjs"],"sourcesContent":["/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(rawString);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n  let startLine = 0;\n\n  while (startLine < lines.length && isBlank(lines[startLine])) {\n    ++startLine;\n  }\n\n  let endLine = lines.length;\n\n  while (endLine > startLine && isBlank(lines[endLine - 1])) {\n    --endLine;\n  } // Return a string of the lines joined with U+000A.\n\n  return lines.slice(startLine, endLine).join('\\n');\n}\n\nfunction isBlank(str) {\n  for (const char of str) {\n    if (char !== ' ' && char !== '\\t') {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @internal\n */\n\nexport function getBlockStringIndentation(value) {\n  var _commonIndent;\n\n  let isFirstLine = true;\n  let isEmptyLine = true;\n  let indent = 0;\n  let commonIndent = null;\n\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.charCodeAt(i)) {\n      case 13:\n        //  \\r\n        if (value.charCodeAt(i + 1) === 10) {\n          ++i; // skip \\r\\n as one symbol\n        }\n\n      // falls through\n\n      case 10:\n        //  \\n\n        isFirstLine = false;\n        isEmptyLine = true;\n        indent = 0;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        ++indent;\n        break;\n\n      default:\n        if (\n          isEmptyLine &&\n          !isFirstLine &&\n          (commonIndent === null || indent < commonIndent)\n        ) {\n          commonIndent = indent;\n        }\n\n        isEmptyLine = false;\n    }\n  }\n\n  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0\n    ? _commonIndent\n    : 0;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, preferMultipleLines = false) {\n  const isSingleLine = !value.includes('\\n');\n  const hasLeadingSpace = value.startsWith(' ') || value.startsWith('\\t');\n  const hasTrailingQuote = value.endsWith('\"');\n  const hasTrailingSlash = value.endsWith('\\\\');\n  const printAsMultipleLines =\n    !isSingleLine ||\n    hasTrailingQuote ||\n    hasTrailingSlash ||\n    preferMultipleLines;\n  let result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n';\n  }\n\n  result += value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,sBAAsBA,CAACC,SAAS,EAAE;EAChD;EACA,MAAMC,KAAK,GAAGD,SAAS,CAACE,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC;;EAE/C,MAAMC,YAAY,GAAGC,yBAAyB,CAACJ,SAAS,CAAC;EAEzD,IAAIG,YAAY,KAAK,CAAC,EAAE;IACtB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;MACrCJ,KAAK,CAACI,CAAC,CAAC,GAAGJ,KAAK,CAACI,CAAC,CAAC,CAACE,KAAK,CAACJ,YAAY,CAAC;IACzC;EACF,CAAC,CAAC;;EAEF,IAAIK,SAAS,GAAG,CAAC;EAEjB,OAAOA,SAAS,GAAGP,KAAK,CAACK,MAAM,IAAIG,OAAO,CAACR,KAAK,CAACO,SAAS,CAAC,CAAC,EAAE;IAC5D,EAAEA,SAAS;EACb;EAEA,IAAIE,OAAO,GAAGT,KAAK,CAACK,MAAM;EAE1B,OAAOI,OAAO,GAAGF,SAAS,IAAIC,OAAO,CAACR,KAAK,CAACS,OAAO,GAAG,CAAC,CAAC,CAAC,EAAE;IACzD,EAAEA,OAAO;EACX,CAAC,CAAC;;EAEF,OAAOT,KAAK,CAACM,KAAK,CAACC,SAAS,EAAEE,OAAO,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;AACnD;AAEA,SAASF,OAAOA,CAACG,GAAG,EAAE;EACpB,KAAK,MAAMC,IAAI,IAAID,GAAG,EAAE;IACtB,IAAIC,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EAAE;MACjC,OAAO,KAAK;IACd;EACF;EAEA,OAAO,IAAI;AACb;AACA;AACA;AACA;;AAEA,OAAO,SAAST,yBAAyBA,CAACU,KAAK,EAAE;EAC/C,IAAIC,aAAa;EAEjB,IAAIC,WAAW,GAAG,IAAI;EACtB,IAAIC,WAAW,GAAG,IAAI;EACtB,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIf,YAAY,GAAG,IAAI;EAEvB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,KAAK,CAACR,MAAM,EAAE,EAAED,CAAC,EAAE;IACrC,QAAQS,KAAK,CAACK,UAAU,CAACd,CAAC,CAAC;MACzB,KAAK,EAAE;QACL;QACA,IAAIS,KAAK,CAACK,UAAU,CAACd,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;UAClC,EAAEA,CAAC,CAAC,CAAC;QACP;;MAEF;;MAEA,KAAK,EAAE;QACL;QACAW,WAAW,GAAG,KAAK;QACnBC,WAAW,GAAG,IAAI;QAClBC,MAAM,GAAG,CAAC;QACV;MAEF,KAAK,CAAC,CAAC,CAAC;;MAER,KAAK,EAAE;QACL;QACA,EAAEA,MAAM;QACR;MAEF;QACE,IACED,WAAW,IACX,CAACD,WAAW,KACXb,YAAY,KAAK,IAAI,IAAIe,MAAM,GAAGf,YAAY,CAAC,EAChD;UACAA,YAAY,GAAGe,MAAM;QACvB;QAEAD,WAAW,GAAG,KAAK;IACvB;EACF;EAEA,OAAO,CAACF,aAAa,GAAGZ,YAAY,MAAM,IAAI,IAAIY,aAAa,KAAK,KAAK,CAAC,GACtEA,aAAa,GACb,CAAC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASK,gBAAgBA,CAACN,KAAK,EAAEO,mBAAmB,GAAG,KAAK,EAAE;EACnE,MAAMC,YAAY,GAAG,CAACR,KAAK,CAACS,QAAQ,CAAC,IAAI,CAAC;EAC1C,MAAMC,eAAe,GAAGV,KAAK,CAACW,UAAU,CAAC,GAAG,CAAC,IAAIX,KAAK,CAACW,UAAU,CAAC,IAAI,CAAC;EACvE,MAAMC,gBAAgB,GAAGZ,KAAK,CAACa,QAAQ,CAAC,GAAG,CAAC;EAC5C,MAAMC,gBAAgB,GAAGd,KAAK,CAACa,QAAQ,CAAC,IAAI,CAAC;EAC7C,MAAME,oBAAoB,GACxB,CAACP,YAAY,IACbI,gBAAgB,IAChBE,gBAAgB,IAChBP,mBAAmB;EACrB,IAAIS,MAAM,GAAG,EAAE,CAAC,CAAC;;EAEjB,IAAID,oBAAoB,IAAI,EAAEP,YAAY,IAAIE,eAAe,CAAC,EAAE;IAC9DM,MAAM,IAAI,IAAI;EAChB;EAEAA,MAAM,IAAIhB,KAAK;EAEf,IAAIe,oBAAoB,EAAE;IACxBC,MAAM,IAAI,IAAI;EAChB;EAEA,OAAO,KAAK,GAAGA,MAAM,CAACC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,GAAG,KAAK;AACxD","ignoreList":[]},"metadata":{},"sourceType":"module"}