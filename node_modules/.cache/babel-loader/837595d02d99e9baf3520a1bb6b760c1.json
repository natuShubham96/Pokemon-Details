{"ast":null,"code":"import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(([responseName, subReason]) => `subfields \"${responseName}\" conflict because ` + reasonMessage(subReason)).join(' and ');\n  }\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(`Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  const fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);\n  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);\n    }\n  }\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false,\n          // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, `\"${name1}\" and \"${name2}\" are different fields`], [node1], [node2]];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    const args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    const args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, `they return conflicting types \"${inspect(type1)}\" and \"${inspect(type2)}\"`], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(argument1 => {\n    const argument2 = arguments2.find(argument => argument.name.value === argument1.name.value);\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\nfunction sameValue(value1, value2) {\n  return print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isListType(type2)) {\n    return true;\n  }\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isNonNullType(type2)) {\n    return true;\n  }\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (cached) {\n    return cached;\n  }\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          const fieldName = selection.name.value;\n          let fieldDef;\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n          const responseName = selection.alias ? selection.alias.value : fieldName;\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case Kind.INLINE_FRAGMENT:\n        {\n          const typeCondition = selection.typeCondition;\n          const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(([reason]) => reason)], [node1, ...conflicts.map(([, fields1]) => fields1).flat()], [node2, ...conflicts.map(([,, fields2]) => fields2).flat()]];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const map = this._data.get(key1);\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}","map":{"version":3,"names":["inspect","GraphQLError","Kind","print","getNamedType","isNonNullType","isLeafType","isObjectType","isListType","isInterfaceType","typeFromAST","reasonMessage","reason","Array","isArray","map","responseName","subReason","join","OverlappingFieldsCanBeMergedRule","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","fields1","fields2","reasonMsg","reportError","concat","parentType","fieldMap","fragmentNames","getFieldsAndFragmentNames","collectConflictsWithin","length","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","fieldMap2","referencedFragmentNames","getReferencedFieldsAndFragmentNames","collectConflictsBetween","referencedFragmentName","fragmentName1","fragmentName2","has","add","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","referencedFragmentName2","referencedFragmentName1","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","fragmentNames1","fragmentNames2","fields","Object","entries","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","field1","field2","node1","def1","node2","def2","_node1$arguments","_node2$arguments","name1","name","value","name2","args1","arguments","args2","sameArguments","type1","type","type2","doTypesConflict","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","find","argument","sameValue","value1","value2","ofType","cached","get","nodeAndDefs","create","_collectFieldsAndFragmentNames","result","keys","set","fragmentType","getSchema","typeCondition","selection","selections","kind","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","flat","constructor","_data","a","b","_this$_data$get","key1","key2","undefined"],"sources":["C:/Users/natus/Desktop/Reliquest Assessment/ui-assessment-pokedex-snr/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isNonNullType,\n  isLeafType,\n  isObjectType,\n  isListType,\n  isInterfaceType,\n} from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            fields1.concat(fields2),\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    const args1 =\n      (_node1$arguments = node1.arguments) !== null &&\n      _node1$arguments !== void 0\n        ? _node1$arguments\n        : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    const args2 =\n      (_node2$arguments = node2.arguments) !== null &&\n      _node2$arguments !== void 0\n        ? _node2$arguments\n        : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every((argument1) => {\n    const argument2 = arguments2.find(\n      (argument) => argument.name.value === argument1.name.value,\n    );\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}