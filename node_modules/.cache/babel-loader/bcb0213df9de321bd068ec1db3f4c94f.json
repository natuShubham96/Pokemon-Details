{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useQuery(query, options) {\n  var _a;\n  var context = useContext(getApolloContext());\n  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n  verifyDocumentType(query, DocumentType.Query);\n  var _b = useState(function () {\n      var watchQueryOptions = createWatchQueryOptions(query, options);\n      var obsQuery = null;\n      if (context.renderPromises) {\n        obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n      }\n      if (!obsQuery) {\n        obsQuery = client.watchQuery(watchQueryOptions);\n        if (context.renderPromises) {\n          context.renderPromises.registerSSRObservable(obsQuery, watchQueryOptions);\n        }\n      }\n      if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && obsQuery.getCurrentResult().loading) {\n        context.renderPromises.addQueryPromise({\n          getOptions: function () {\n            return createWatchQueryOptions(query, options);\n          },\n          fetchData: function () {\n            return new Promise(function (resolve) {\n              var sub = obsQuery.subscribe({\n                next: function (result) {\n                  if (!result.loading) {\n                    resolve();\n                    sub.unsubscribe();\n                  }\n                },\n                error: function () {\n                  resolve();\n                  sub.unsubscribe();\n                },\n                complete: function () {\n                  resolve();\n                }\n              });\n            });\n          }\n        }, function () {\n          return null;\n        });\n      }\n      return obsQuery;\n    }),\n    obsQuery = _b[0],\n    setObsQuery = _b[1];\n  var _c = useState(function () {\n      var _a, _b;\n      var result = obsQuery.getCurrentResult();\n      if (!result.loading && options) {\n        if (result.error) {\n          (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n        } else if (result.data) {\n          (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n        }\n      }\n      return result;\n    }),\n    result = _c[0],\n    setResult = _c[1];\n  var ref = useRef({\n    client: client,\n    query: query,\n    options: options,\n    result: result,\n    previousData: void 0,\n    watchQueryOptions: createWatchQueryOptions(query, options)\n  });\n  useEffect(function () {\n    var _a, _b;\n    var watchQueryOptions = createWatchQueryOptions(query, options);\n    var nextResult;\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      var obsQuery_1 = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery_1);\n      nextResult = obsQuery_1.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(function () {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n    if (nextResult) {\n      var previousResult = ref.current.result;\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n      setResult(ref.current.result = nextResult);\n      if (!nextResult.loading && options) {\n        if (!result.loading) {\n          if (result.error) {\n            (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n          } else if (result.data) {\n            (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n          }\n        }\n      }\n    }\n    Object.assign(ref.current, {\n      client: client,\n      query: query,\n      options: options\n    });\n  }, [obsQuery, client, query, options]);\n  useEffect(function () {\n    if (context.renderPromises) {\n      return;\n    }\n    var subscription = obsQuery.subscribe(onNext, onError);\n    function onNext() {\n      var _a, _b;\n      var previousResult = ref.current.result;\n      var result = obsQuery.getCurrentResult();\n      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n        return;\n      }\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n      setResult(ref.current.result = result);\n      if (!result.loading) {\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, result.data);\n      }\n    }\n    function onError(error) {\n      var _a, _b;\n      var last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        throw error;\n      }\n      var previousResult = ref.current.result;\n      if (previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error,\n          loading: false,\n          networkStatus: NetworkStatus.error\n        });\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n      }\n    }\n    return function () {\n      return subscription.unsubscribe();\n    };\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n  var partial;\n  _a = result, partial = _a.partial, result = __rest(_a, [\"partial\"]);\n  {\n    if (partial && (options === null || options === void 0 ? void 0 : options.partialRefetch) && !result.loading && (!result.data || Object.keys(result.data).length === 0) && obsQuery.options.fetchPolicy !== 'cache-only') {\n      result = __assign(__assign({}, result), {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      obsQuery.refetch();\n    }\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && result.loading) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options)).catch(function () {});\n    }\n  }\n  if ((context.renderPromises || client.disableNetworkFetches) && (options === null || options === void 0 ? void 0 : options.ssr) === false) {\n    result = ref.current.result = {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    };\n  } else if ((options === null || options === void 0 ? void 0 : options.skip) || (options === null || options === void 0 ? void 0 : options.fetchPolicy) === 'standby') {\n    result = {\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    };\n  }\n  if (result.errors && result.errors.length) {\n    result = __assign(__assign({}, result), {\n      error: result.error || new ApolloError({\n        graphQLErrors: result.errors\n      })\n    });\n  }\n  var obsQueryFields = useMemo(function () {\n    return {\n      refetch: obsQuery.refetch.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n    };\n  }, [obsQuery]);\n  return __assign(__assign(__assign({}, obsQueryFields), {\n    variables: obsQuery.variables,\n    client: client,\n    called: true,\n    previousData: ref.current.previousData\n  }), result);\n}\nfunction createWatchQueryOptions(query, options) {\n  var _a;\n  if (options === void 0) {\n    options = {};\n  }\n  var skip = options.skip,\n    ssr = options.ssr,\n    onCompleted = options.onCompleted,\n    onError = options.onError,\n    displayName = options.displayName,\n    watchQueryOptions = __rest(options, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\"]);\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (((_a = watchQueryOptions.context) === null || _a === void 0 ? void 0 : _a.renderPromises) && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n  return __assign({\n    query: query\n  }, watchQueryOptions);\n}","map":{"version":3,"names":["useContext","useEffect","useMemo","useRef","useState","equal","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","useQuery","query","options","context","client","Query","_b","watchQueryOptions","createWatchQueryOptions","obsQuery","renderPromises","getSSRObservable","watchQuery","registerSSRObservable","ssr","skip","getCurrentResult","loading","addQueryPromise","getOptions","fetchData","Promise","resolve","sub","subscribe","next","result","unsubscribe","error","complete","setObsQuery","_c","_a","onError","call","data","onCompleted","setResult","ref","previousData","nextResult","current","obsQuery_1","setOptions","catch","previousResult","Object","assign","subscription","onNext","networkStatus","last","resetLastResults","hasOwnProperty","disableNetworkFetches","partial","__rest","partialRefetch","keys","length","fetchPolicy","__assign","refetch","ready","errors","graphQLErrors","obsQueryFields","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","variables","called","displayName"],"sources":["../../../src/react/hooks/useQuery.ts"],"sourcesContent":["import { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { OperationVariables } from '../../core';\nimport { getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n): QueryResult<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(query, DocumentType.Query);\n  const [obsQuery, setObsQuery] = useState(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options);\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    let obsQuery: ObservableQuery<TData, TVariables> | null = null;\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      // Is it safe (StrictMode/memory-wise) to call client.watchQuery here?\n      obsQuery = client.watchQuery(watchQueryOptions);\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(\n          obsQuery,\n          watchQueryOptions,\n        );\n      }\n    }\n\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      obsQuery.getCurrentResult().loading\n    ) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      context.renderPromises.addQueryPromise(\n        {\n          // The only options which seem to actually be used by the\n          // RenderPromises class are query and variables.\n          getOptions: () => createWatchQueryOptions(query, options),\n          fetchData: () => new Promise<void>((resolve) => {\n            const sub = obsQuery!.subscribe({\n              next(result) {\n                if (!result.loading) {\n                  resolve()\n                  sub.unsubscribe();\n                }\n              },\n              error() {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete() {\n                resolve();\n              },\n            });\n          }),\n        },\n        // This callback never seemed to do anything\n        () => null,\n      );\n    }\n\n    return obsQuery;\n  });\n\n  let [result, setResult] = useState(() => {\n    const result = obsQuery.getCurrentResult();\n    if (!result.loading && options) {\n      if (result.error) {\n        options.onError?.(result.error);\n      } else if (result.data) {\n        options.onCompleted?.(result.data);\n      }\n    }\n\n    return result;\n  });\n\n  const ref = useRef({\n    client,\n    query,\n    options,\n    result,\n    previousData: void 0 as TData | undefined,\n    watchQueryOptions: createWatchQueryOptions(query, options),\n  });\n\n  // An effect to recreate the obsQuery whenever the client or query changes.\n  // This effect is also responsible for checking and updating the obsQuery\n  // options whenever they change.\n  useEffect(() => {\n    const watchQueryOptions = createWatchQueryOptions(query, options);\n    let nextResult: ApolloQueryResult<TData> | undefined;\n    if (ref.current.client !== client || !equal(ref.current.query, query)) {\n      const obsQuery = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery);\n      nextResult = obsQuery.getCurrentResult();\n    } else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(() => {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      const previousResult = ref.current.result;\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n      if (!nextResult.loading && options) {\n        if (!result.loading) {\n          if (result.error) {\n            options.onError?.(result.error);\n          } else if (result.data) {\n            options.onCompleted?.(result.data);\n          }\n        }\n      }\n    }\n\n    Object.assign(ref.current, { client, query, options });\n  }, [obsQuery, client, query, options]);\n\n  // An effect to subscribe to the current observable query\n  useEffect(() => {\n    if (context.renderPromises) {\n      return;\n    }\n\n    let subscription = obsQuery.subscribe(onNext, onError);\n    // We use `getCurrentResult()` instead of the callback argument because\n    // the values differ slightly. Specifically, loading results will have\n    // an empty object for data instead of `undefined` for some reason.\n    function onNext() {\n      const previousResult = ref.current.result;\n      const result = obsQuery.getCurrentResult();\n      // Make sure we're not attempting to re-render similar results\n      if (\n        previousResult &&\n        previousResult.loading === result.loading &&\n        previousResult.networkStatus === result.networkStatus &&\n        equal(previousResult.data, result.data)\n      ) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n      if (!result.loading) {\n        ref.current.options?.onCompleted?.(result.data);\n      }\n    }\n\n    function onError(error: Error) {\n      const last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n      // Unfortunately, if `lastError` is set in the current\n      // `observableQuery` when the subscription is re-created,\n      // the subscription will immediately receive the error, which will\n      // cause it to terminate again. To avoid this, we first clear\n      // the last error/result from the `observableQuery` before re-starting\n      // the subscription, and restore it afterwards (so the subscription\n      // has a chance to stay open).\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        // The error is not a GraphQL error\n        throw error;\n      }\n\n      const previousResult = ref.current.result;\n      if (\n        (previousResult && previousResult.loading) ||\n        !equal(error, previousResult.error)\n      ) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error as ApolloError,\n          loading: false,\n          networkStatus: NetworkStatus.error,\n        });\n        ref.current.options?.onError?.(error as ApolloError);\n      }\n    }\n\n    return () => subscription.unsubscribe();\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n\n  let partial: boolean | undefined;\n  ({ partial, ...result } = result);\n\n  {\n    // BAD BOY CODE BLOCK WHERE WE PUT SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      partial &&\n      options?.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      obsQuery.options.fetchPolicy !== 'cache-only'\n    ) {\n      result = {\n        ...result,\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      };\n\n      obsQuery.refetch();\n    }\n\n    // TODO: This is a hack to make sure useLazyQuery executions update the\n    // obsevable query options for ssr.\n    if (\n      context.renderPromises &&\n      options?.ssr !== false &&\n      !options?.skip &&\n      result.loading\n    ) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options)).catch(() => {});\n    }\n  }\n\n  if (\n    (context.renderPromises || client.disableNetworkFetches) &&\n    options?.ssr === false\n  ) {\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    result = ref.current.result = {\n      loading: true,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.loading,\n    };\n  } else if (options?.skip || options?.fetchPolicy === 'standby') {\n    // When skipping a query (ie. we're not querying for data but still want to\n    // render children), make sure the `data` is cleared out and `loading` is\n    // set to `false` (since we aren't loading anything).\n    //\n    // NOTE: We no longer think this is the correct behavior. Skipping should\n    // not automatically set `data` to `undefined`, but instead leave the\n    // previous data in place. In other words, skipping should not mandate that\n    // previously received data is all of a sudden removed. Unfortunately,\n    // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n    // to address this.\n    result = {\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      networkStatus: NetworkStatus.ready,\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    result = {\n      ...result,\n      error: result.error || new ApolloError({ graphQLErrors: result.errors }),\n    };\n  }\n\n  const obsQueryFields = useMemo(() => ({\n    refetch: obsQuery.refetch.bind(obsQuery),\n    fetchMore: obsQuery.fetchMore.bind(obsQuery),\n    updateQuery: obsQuery.updateQuery.bind(obsQuery),\n    startPolling: obsQuery.startPolling.bind(obsQuery),\n    stopPolling: obsQuery.stopPolling.bind(obsQuery),\n    subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n  }), [obsQuery]);\n\n  return {\n    ...obsQueryFields,\n    variables: obsQuery.variables,\n    client,\n    called: true,\n    previousData: ref.current.previousData,\n    ...result,\n  };\n}\n\nfunction createWatchQueryOptions<TData, TVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = {},\n): WatchQueryOptions<TVariables, TData> {\n  // TODO: For some reason, we pass context, which is the React Apollo Context,\n  // into observable queries, and test for that.\n  // removing hook specific options\n  const {\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    ...watchQueryOptions\n  } = options;\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (\n    watchQueryOptions.context?.renderPromises &&\n    (\n      watchQueryOptions.fetchPolicy === 'network-only' ||\n      watchQueryOptions.fetchPolicy === 'cache-and-network'\n    )\n  ) {\n    // this behavior was added to react-apollo without explanation in this PR\n    // https://github.com/apollographql/react-apollo/pull/1579\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    // cache-first is the default policy, but we explicitly assign it here so\n    // the cache policies computed based on options can be cleared\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  return { query, ...watchQueryOptions };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}